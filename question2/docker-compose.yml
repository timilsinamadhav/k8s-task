version: '3.8'

services:
  # PostgreSQL Database
  database:
    image: postgres:15-alpine
    container_name: microservices_db
    environment:
      POSTGRES_DB: ${DB_NAME:-microservices_db}
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-password}
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256 --auth-local=scram-sha-256"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db.sql:/docker-entrypoint-initdb.d/init-db.sql:ro
    ports:
      - "${DB_PORT:-5432}:5432"
    networks:
      - microservices_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-postgres} -d ${DB_NAME:-microservices_db}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M

  # API Service (Node.js/Express)
  api-service:
    build:
      context: ./api-service
      dockerfile: Dockerfile
    container_name: microservices_api
    environment:
      NODE_ENV: ${NODE_ENV:-development}
      PORT: 3000
      DB_HOST: database
      DB_PORT: 5432
      DB_NAME: ${DB_NAME:-microservices_db}
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-password}
    ports:
      - "${API_PORT:-3000}:3000"
    depends_on:
      database:
        condition: service_healthy
    networks:
      - microservices_network
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3000/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1); }).on('error', () => process.exit(1));\""]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
    volumes:
      # Development volume mount for hot reloading (comment out for production)
      - ./api-service/src:/app/src:ro

  # Worker Service (Python)
  worker-service:
    build:
      context: ./worker-service
      dockerfile: Dockerfile
    container_name: microservices_worker
    environment:
      ENVIRONMENT: ${NODE_ENV:-development}
      DB_HOST: database
      DB_PORT: 5432
      DB_NAME: ${DB_NAME:-microservices_db}
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-password}
      PROCESS_INTERVAL: ${WORKER_INTERVAL:-30}
    depends_on:
      database:
        condition: service_healthy
    networks:
      - microservices_network
    healthcheck:
      test: ["CMD-SHELL", "python -c \"import psycopg2; import os; conn = psycopg2.connect(host=os.getenv('DB_HOST'), port=int(os.getenv('DB_PORT', '5432')), database=os.getenv('DB_NAME'), user=os.getenv('DB_USER'), password=os.getenv('DB_PASSWORD')); conn.close()\""]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M
    volumes:
      # Development volume mount for hot reloading (comment out for production)
      - ./worker-service/src:/app/src:ro

  # Frontend Service (React + Nginx)
  frontend-service:
    build:
      context: ./frontend-service
      dockerfile: Dockerfile
      args:
        REACT_APP_API_URL: ${REACT_APP_API_URL:-/api}
        REACT_APP_BUILD_TIME: ${BUILD_TIME:-$(date -u +%Y-%m-%dT%H:%M:%SZ)}
    container_name: microservices_frontend
    environment:
      NODE_ENV: ${NODE_ENV:-production}
    ports:
      - "${FRONTEND_PORT:-8080}:3000"
    depends_on:
      api-service:
        condition: service_healthy
    networks:
      - microservices_network
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 128M
        reservations:
          memory: 64M

networks:
  microservices_network:
    driver: bridge
    name: microservices_network
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  postgres_data:
    driver: local
    name: microservices_postgres_data
