name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: docker.io
  REGISTRY_USERNAME: timilsinamadhav
  HELM_RELEASE_NAME: microservices-app
  KUBE_NAMESPACE: default

jobs:
  # Build and Deploy
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to DockerHub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ env.REGISTRY_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Generate image tag
      id: meta
      run: |
        SHORT_SHA=$(git rev-parse --short HEAD)
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        VERSION=${TIMESTAMP}-${SHORT_SHA}
        echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
        echo "Building version: ${VERSION}"

    - name: Build and push images
      run: |
        # Build and push API Service
        docker build -t ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/api-service:latest \
                     -t ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/api-service:${{ steps.meta.outputs.VERSION }} \
                     ./api-service
        docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/api-service:latest
        docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/api-service:${{ steps.meta.outputs.VERSION }}

        # Build and push Worker Service
        docker build -t ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/worker-service:latest \
                     -t ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/worker-service:${{ steps.meta.outputs.VERSION }} \
                     ./worker-service
        docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/worker-service:latest
        docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/worker-service:${{ steps.meta.outputs.VERSION }}

        # Build and push Frontend Service
        docker build -t ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/frontend-service:latest \
                     -t ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/frontend-service:${{ steps.meta.outputs.VERSION }} \
                     --build-arg REACT_APP_API_URL=/api \
                     --build-arg REACT_APP_BUILD_TIME=${{ steps.meta.outputs.VERSION }} \
                     ./frontend-service
        docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/frontend-service:latest
        docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/frontend-service:${{ steps.meta.outputs.VERSION }}

    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: '1.28.0'

    - name: Configure kubectl
      run: |
        # Configure kubeconfig (assumes KUBECONFIG secret is base64 encoded)
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config
        kubectl config current-context

    - name: Create namespace
      run: |
        kubectl create namespace ${{ env.KUBE_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy with Helm
      run: |
        helm upgrade --install ${{ env.HELM_RELEASE_NAME }} ./helm-chart \
          --namespace ${{ env.KUBE_NAMESPACE }} \
          --set image.tag=${{ steps.meta.outputs.VERSION }} \
          --set apiService.image.tag=${{ steps.meta.outputs.VERSION }} \
          --set workerService.image.tag=${{ steps.meta.outputs.VERSION }} \
          --set frontendService.image.tag=${{ steps.meta.outputs.VERSION }} \
          --set environment=production \
          --wait \
          --timeout=10m \
          --atomic

    - name: Verify deployment
      run: |
        kubectl get pods -n ${{ env.KUBE_NAMESPACE }} -l app.kubernetes.io/instance=${{ env.HELM_RELEASE_NAME }}
        kubectl wait --for=condition=available --timeout=300s deployment -n ${{ env.KUBE_NAMESPACE }} -l app.kubernetes.io/instance=${{ env.HELM_RELEASE_NAME }}
        echo "âœ… Deployment successful! Version: ${{ steps.meta.outputs.VERSION }}"

  # Test (for PRs)
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Test API Service
      run: |
        cd api-service
        npm install
        npm test || echo "No tests configured"

    - name: Test Frontend Service
      run: |
        cd frontend-service
        npm install
        npm test -- --coverage --watchAll=false || echo "No tests configured"

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Test Worker Service
      run: |
        cd worker-service
        pip install -r requirements.txt
        python -m pytest || echo "No tests configured"